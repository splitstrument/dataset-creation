import simpleaudio
import os
import argparse
import sys
import keyboard
from marker import TrackMarker
import yaml
from helperutils.boolean_argparse import str2bool
from helperutils.stemloader import StemLoader
from threading import Thread

parser = argparse.ArgumentParser(description='Skim through tracks to check their quality')
parser.add_argument('--source-folder', required=True,
                    help='path to folder containing tracks as generated by `data_organizer`')
parser.add_argument('--instrument', default='mix', help='instrument to check')
parser.add_argument('--splits', default=5, help='how many parts per stem should be generated to skim through')
parser.add_argument("--cautious-mode", type=str2bool, default=False,
                    help='should marker not skip steam when marking')
parser.add_argument("--save-marks-metadata", type=str2bool, default=False,
                    help='should marks be written to separate file for safekeeping')
parser.add_argument("--from-index", type=int, help='from what track to start')
parser.add_argument("--to-index", type=int, help='at what track to stop')
parser.add_argument("--additional-instruments", default=[], nargs='*', help='what additional instruments to listen to')
args = parser.parse_args()

if not os.path.isdir(args.source_folder):
    sys.exit('Provided path to tracks is not a folder')

instruments = args.additional_instruments
instruments.append(args.instrument)

stem_loader = StemLoader(args.source_folder, os.listdir(args.source_folder), instruments)

current_split = None
marker = None
should_skip_next = False


def next_stem():
    if current_split is not None:
        current_split.stop()


def skip_next(skip=False):
    global should_skip_next
    if skip:
        should_skip_next = True
        next_stem()
        return True
    else:
        previous = should_skip_next
        should_skip_next = False
        return previous


def accept():
    if not args.cautious_mode:
        mark(TrackMarker.mark_audible)
    else:
        skip_next(True)


def mark(marker_method):
    if marker is not None:
        marker_method(marker)
    if not args.cautious_mode:
        skip_next(True)


keyboard.add_hotkey('b', lambda: mark(TrackMarker.mark_bleed), suppress=True)
keyboard.add_hotkey('q', lambda: mark(TrackMarker.mark_bad_quality), suppress=True)
keyboard.add_hotkey('m', lambda: mark(TrackMarker.mark_missing), suppress=True)
keyboard.add_hotkey('i', lambda: mark(TrackMarker.mark_inaudible), suppress=True)
keyboard.add_hotkey('a', lambda: mark(TrackMarker.mark_audible), suppress=True)
keyboard.add_hotkey('l', lambda: mark(TrackMarker.mark_mislabeled), suppress=True)
keyboard.add_hotkey('d', lambda: mark(TrackMarker.mark_detailed), suppress=True)
keyboard.add_hotkey('space', lambda: next_stem(), suppress=True)
keyboard.add_hotkey('enter', lambda: accept(), suppress=True)


def detect_leading_silence(sound, silence_threshold=-50.0, chunk_size=10):
    trim_ms = 0
    while sound[trim_ms:trim_ms + chunk_size].dBFS < silence_threshold and trim_ms < len(sound):
        trim_ms += chunk_size

    return trim_ms


def listen_to_stem(split, split_length, stem):
    global current_split
    print('Listening to split {0}'.format(split + 1))
    current_split = simpleaudio.play_buffer(
        stem[split_length * split:split_length * (split + 1)].raw_data,
        num_channels=stem.channels,
        bytes_per_sample=stem.sample_width,
        sample_rate=stem.frame_rate
    )
    current_split.wait_done()


def load_trimmed_stem(stem, path):
    file_path = os.path.join(path, stem)
    stem = stem_loader.get_stem(file_path)
    Thread(target=stem_loader.preload_next, args=(file_path,)).start()
    start_trim = detect_leading_silence(stem)
    end_trim = detect_leading_silence(stem.reverse())
    duration = len(stem)
    return stem[start_trim:duration - end_trim]


def listen_to_instrument_stems(path):
    for stem in os.listdir(path):
        print('Listening to stem {0}'.format(stem))
        stem = load_trimmed_stem(stem, path)
        if len(stem) == 0:
            mark(TrackMarker.mark_missing)

        split_length = stem.duration_seconds * 1000 / args.splits

        for split in range(args.splits):
            listen_to_stem(split, split_length, stem)

            if skip_next():
                break


marks_filename = 'marks_{0}.yaml'.format(args.instrument)
if args.save_marks_metadata and os.path.isfile(marks_filename):
    with open(marks_filename) as file:
        marks = yaml.load(file, Loader=yaml.FullLoader)
else:
    marks = {}

index = 0
from_index = args.from_index
to_index = args.to_index
for track in os.listdir(args.source_folder):
    if from_index is not None and index < from_index:
        index += 1
        continue
    if to_index is not None and index >= to_index:
        continue

    track_name = os.path.basename(track)
    print('\nTrack {0}: {1}'.format(index, track_name))
    track_path = os.path.join(args.source_folder, track)
    marker = TrackMarker(track_path, args.instrument, args.cautious_mode)
    if track in marks:
        print('Found in marks metadata, using existing marks and skipping'.format(track_name))
        marker.set_marks(marks[track])
        marker.write_marks()
    elif marker.is_checked:
        print('Found marks files, using existing marks and skipping'.format(track_name))
        marks[track] = marker.get_marks()
    else:
        instrument_found = False
        print('Listening to track {0}'.format(track_name))
        for instrument in instruments:
            instrument_path = os.path.join(track_path, instrument)
            if os.path.isdir(instrument_path):
                print('Listening to {0}'.format(instrument))
                instrument_found = True
                listen_to_instrument_stems(instrument_path)

        if not instrument_found:
            marker.mark_missing()

        mark_metadata = marker.write_marks()
        if args.save_marks_metadata:
            marks[track] = marker.get_marks()

    index += 1

if args.save_marks_metadata:
    with open(marks_filename, 'w') as file:
        yaml.dump(marks, file)
